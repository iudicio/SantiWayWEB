# Сегодня мы разберемся как работать с RabbitMQ и очередями.
## Ключевые понятия
**Publisher** - тот, кто отправляет задачу в RabbitMQ
**Consumer** - тот, кто обрабатывает сообщения из очереди

**Кто такой брокер сообщений RabbitMQ?**
По факту это посредник между нашими микросервисами. Он гарантирует, что сообщение дойдет до получателя, если будет какой-то сбой или получатель будет недоступен.

Вместо того, чтобы отправлять запрос напрямую в микросервис и ждать, пока он ответит, мы отправляем сообщение в брокер, от которого получаем мгновенный ответ, что он получил сообщение и можем работать дальше, пока оно обрабатывается в микросервисах

Мы используем еще Celery, что упрощает работу с RabbitMQ.
## Как подключаться к RabbitMQ
Формат адрессов для подключения к RabbitMQ: ```amqp://<логин>:<пароль>@<адрес>:<порт>```  
*Где найти все эти данные я описал в Readme к RabbitMQ*  
## Рассмотрим работу Celery + RabbitMQ на примере микросервиса Vendor.

Обязательные файлы для структуры, которая используется в микросервисе это celery_app.py и tasks.py
### В celery_app.py мы прописываем настройки нашего Consumer

```app = Celery('json_processor', broker=broker)```  
*Мы создаем приложение обработки очереди с именем json_processor, которое общается с брокером*  

```
app.conf.update (  
    task_serializer='json',  
    accept_content=['json'],  
    result_serializer='json',  
    imports=("tasks",),  
    task_acks_late=True,
    worker_prefetch_multiplier=1,  
)
```

Важный параметр здесь это  **imports=("tasks")** - файл, в котором лежат tasks, которые мы можем обрабатывать в нашем случае, это tasks.py

### Рассмотрим файл tasks.py
### Обработка сообщения
Декоратор ```@app.task(name="vendor", queue="vendor_queue")``` является ключевым.  
Он означает, что следующая функция будет работать с task с именем vendor в очереди vendor_queue
### Отправка сообщения
```app.send_task("esWriter", args=[messages], queue="es_writer")```  
Означает, что наше приложение отправляет task с именем esWriter, телом которого является содержимое переменной messages, task отправляется в очередь es_writer
Можно заметить, что наш consumer стал publisher. Это нормально. Одно приложение может быть как consumer, так и publisher

